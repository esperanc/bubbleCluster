
// Returns a radial kernel function for r0 and r1 as described
// in the bubble cluster paper...
//
function radial_kernel (r0,r1) {
    var a = r1-r0;
    var f = 1.0 / (a*a);
    var b = r0;
    return function (d) {
        var r = d-a-b;
        if (r > 0) return 0.0;
        return f * r * r;
    }
}

// 
// Returns a radial function as described in the bubble cluster
// paper...
//
function radial (x0,y0,r0,r1) {
    var k = radial_kernel (r0, r1);
    var a = r1-r0;
    var f = 1.0 / (a*a);
    var b = r0;
    var r1sqr = r1*r1;
    return function (x,y) {
        x -= x0;
        y -= y0; 
        var d2 = x*x+y*y;
        if (d2 > r1sqr) return 0.0;
        var r = Math.sqrt(d2) - a - b;
        //if (r > 0) return 0.0;
        return f * r * r;
    }
}

//
// Represents a bounding box in 2D
//
class Bbox {

    // Constructor 
    constructor (x,y,width,height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }

    // Returns a new bbox with the union of this and other
    union (other) {
        var x = Math.min (this.x, other.x);
        var y = Math.min (this.y, other.y);
        var w = Math.max (this.x + this.width, other.x + other.width) - x;
        var h = Math.max (this.y + this.height, other.y + other.height) - y;
        return new Bbox (x,y,w,h);
    }

    // Returns a new bbox with the intersection of this and other, or null
    // if no intersection exists
    intersection (other) {
        var x = Math.max (this.x, other.x);
        var y = Math.max (this.y, other.y);
        var w = Math.min (this.x + this.width, other.x + other.width) - x;
        var h = Math.min (this.y + this.height, other.y + other.height) - y;
        if (w>0 && h>0) {
            return new Bbox (x,y,w,h);
        }
        return null;
    }
}

//
// Encapsulates an object that can be manipulated
//
class ClusterElement {

    // By default, a circle object
    constructor (center, radius, dilation) {
        this.center = center;
        this.radius = radius;
        this.dilation = dilation || 10;
        this.set_field (dilation);
        this.dirty = true; // Tells if the field associated with the element has changed
    }

    // Alter the field generated by this element by choosing another dilation
    set_field (dilation) {
        if (dilation != this.dilation) this.dirty = true;
        this.dilation = dilation;
        this.field = radial (this.center.x, this.center.y, this.radius, this.radius+this.dilation);
    }

    // Returns a bounding box for the element
    bbox () {
        var sz = this.radius + this.dilation;
        return new Bbox (this.center.x - sz, this.center.y - sz, sz*2, sz*2);
    }


    // True if element contains point p
    contains (p) {
        return distPoints (this.center, p) <= this.radius;
    }

    // Draw the object
    draw() {
        ellipse (this.center.x, this.center.y, this.radius*2, this.radius*2);
    }


    // returns the distance between this element and another element
    distance (other) {
        if (other instanceof ClusterElement)
            return Math.max(distPoints (this.center, other.center)-this.radius-other.radius,0);
        return other.distance(this);
    }

    // returns the distance between this element and a point
    distancePoint (p) {
        return Math.max(distPoints (this.center, p)-this.radius,0);
    }

    // applies translation given by vector v to this element
    translate (v) {
        this.center.x += v.x;
        this.center.y += v.y;
        this.dirty = true;
    }
}

// A line segment element
class ClusterConnector {
  
    // Constructor from two elements
    constructor (elem1, elem2, radius, dilation) {
        this.elem1 = elem1;
        this.elem2 = elem2;
        this.radius = radius;
        this.dilation = dilation || 10;
        this.set_field (dilation);
        this.dirty = true; // Tells if the field associated with the element has changed
    }
  
    // Alter the field generated by this element by choosing another dilation
    set_field (dilation) {
        if (dilation != this.dilation) this.dirty = true;
        this.dilation = dilation;
        var kernel = radial_kernel (this.radius, this.radius+this.dilation);
        this.field = function (x,y) {
            var r = distPointLineSegment (this.elem1.center, this.elem2.center, makeVector (x,y));
            return kernel (r);
        }
    }
  
    // Returns a bounding box for the element
    bbox () {
        var sz = this.radius + this.dilation;
        return (new Bbox (this.elem1.center.x - sz, this.elem1.center.y - sz, sz*2, sz*2))
               .union(new Bbox (this.elem2.center.x - sz, this.elem2.center.y - sz, sz*2, sz*2)) ;
    }


    // True if element contains point p
    contains (p) {
        var r = distPointLineSegment (this.elem1.center, this.elem2.center, p);
        return r <= this.radius;
    }

    // Draw the object
    draw() {
        line (this.elem1.center.x, this.elem1.center.y, this.elem2.center.x, this.elem2.center.y);
    }


    // returns the distance between this connector and another element
    distance (other) {
        if (other instanceof ClusterElement)
            return Math.max(distPointLineSegment (this.elem1.center, this.elem2.center, other.center) - this.radius - other.radius, 0);
        if (other instanceof ClusterConnector)
            return Math.max(
                Math.min(distPointLineSegment (this.elem1.center, this.elem2.center, other.elem1.center),
                         distPointLineSegment (this.elem1.center, this.elem2.center, other.elem2.center),
                         distPointLineSegment (other.elem1.center, other.elem2.center, this.elem1.center),
                         distPointLineSegment (other.elem1.center, other.elem2.center, this.elem2.center)) - this.radius - other.radius, 0);
        return other.distance(this);
    }

    // returns the distance between this element and a point
    distancePoint (p) {
        return Math.max(distPointLineSegment (this.elem1.center, this.elem2.center, p)-this.radius,0);
    }

    // returns true if this segment crosses segment a-b
    crosses (a,b) {
        return lineSegmentsIntersect2D(this.elem1.center,this.elem2.center,a,b);
    }

    // applies translation given by vector v to this element
    translate (v) {
        // No modification necessary since position is given by other elements
        this.dirty = true;
    }
}

// A group of elements or clusters
class Cluster extends Array {

    constructor () {
        super ();
        this.outline = [];
        this.dirty = false;
    }

    // Alter the field generated by this cluster by choosing dilation
    set_field (dilation) {
        this.dirty = false;
        for (let x of this) {
            x.set_field (dilation);
            this.dirty = this.dirty || x.dirty;
        }
        var self = this;
        this.field = function (x,y) {
            var s = 0.0;
            for (let e of self) {
                s += e.field (x,y);
            }
            return s;
        }
    }

    // Returns a bounding box for the cluster
    bbox () {
        if (this.length == 0) return null;
        var box = this[0].bbox();
        for (var i = 1; i < this.length; i++)
            box = box.union(this[i].bbox());
        return box;
    }

    // True if cluster contains point p
    contains (p) {
        for (let e of this) {
            if (e.contains (p)) return true;
        }
        return false;
    }

    // Returns a set of common elements between this cluster and other cluster
    common (other) {
        var otherset = new Set(other);
        var result = new Set();
        for (let e of this) {
            if (otherset.has(e)) result.add(e);
        }
        return result;
    }

    // Draw the cluster
    draw() {
        for (let x of this) x.draw();
    }

    // returns the distance between this cluster and another cluster/element
    distance (other) {
        var mind = 1e10; // A Big number
        for (let x of this) {
            var d = other.distance (x);
            mind = Math.min (mind, d);
        }
        return mind;
    }

    // returns the distance between this cluster and a point
    distancePoint (p) {
        var mind = 1e10; // A Big number
        for (let x of this) {
            var d = x.distancePoint(p);
            mind = Math.min (mind, d);
        }
        return mind;
    }


    // Removes an element e from this cluster if it exists. 
    // Returns true if element was removed
    remove (e) {
        for (var i = 0; i < this.length; i++) {
            if (e == this [i]) {
                this.splice (i, 1);
                return true;
            }
        }
        return false;
    } 

    // Returns a flat list of all elements of this cluster, including
    // those which are descendents of child clusters
    elements () {
        var result = [];
        for (let c of this) {
            if  (c instanceof Cluster) {
                for (let e of c.elements()) {
                    result.push(e);
                }
            }
            else if (c instanceof ClusterElement) {
                result.push (c);
            }
        }
        return result;
    }

    // Returns a flat list of all connectors of this cluster, including
    // those which are descendents of child clusters
    connectors () {
        var result = [];
        for (let c of this) {
            if  (c instanceof Cluster) {
                for (let e of c.connectors()) {
                    result.push(e);
                }
            }
            else if (c instanceof ClusterConnector) {
                result.push (c);
            }
        }
        return result;
    }

    // Return the closest element of this cluster to point p
    closestElement (p) {
        var closest = null;
        var mind = 1e10;
        for (let e of this.elements()) {
            var d = e.distancePoint (p);
            if (d < mind) {
                closest = e;
                mind = d;
            }
        }
        return closest;
    }

    // applies translation given by vector v to this cluster
    translate (v) {
        for (let e of this) e.translate(v);
        for (let o of this.outline) o.translate(v);
        this.dirty = true;
    }
}

// Provides functionality for considering some pairs of elements as belonging
// to the same cluster
class ClusterExclusion {

    // Provides pair exclusion testing for elements of cluster
    // that are on opposite sides of line pq. Only considers 
    // elements within a radius distance of pq.
    constructor (cluster, p, q, radius) {
        radius = radius || 10;
        this.aset = new Set();
        this.bset = new Set();
        for (let e of cluster.elements()) {
            if (distPointLineSegment (p,q,e.center) <= radius) {
                if (orientation2D (p,q,e.center) < 0) {
                    this.aset.add (e);
                }
                else {
                    this.bset.add (e);
                }
            }
        } 
    }

    // returns the total number of excluded pairs
    count () {
        return this.aset.size * this.bset.size;
    }

    // returns a function of the form exclusion(a,b) that yields 
    // true if element pair a,b is an excluded pair
    exclusion () {
        var self = this;
        return function (a, b) {
            if (a instanceof ClusterElement && b instanceof ClusterElement) {
                if (self.aset.has(a)) return self.bset.has(b);
                return self.bset.has(a) && self.aset.has(b);
            } else if (a instanceof Cluster && b instanceof Cluster) {
                var ina = false;
                var inb = false;
                for (let aelement of a.elements()) {
                    if (self.aset.has (aelement)) ina = true;
                    if (self.bset.has (aelement)) inb = true;
                } 
                for (let belement of b.elements()) {
                    if (self.aset.has (belement)) { if (inb) return true; }
                    if (self.bset.has (belement)) { if (ina) return true; }
                }
                return false;
            }
            console.assert (a instanceof ClusterConnector || b instanceof ClusterConnector);
        }
    }
}



//
// A matrix of floats used to cache samples obtained
// with GridSample's addSample method
//
class SampleCache {
    constructor (imin,imax,jmin,jmax) {
        this.imin = imin;
        this.imax = imax;
        this.jmin = jmin;
        this.jmax = jmax;
        var n = imax-imin;
        this.m = [];
        for (var i = 0; i < n; i++) this.m[i] = [];
    }
    
    setvalue (i,j,v) {
        this.m[i-this.imin][j-this.jmin] = v;
    }

    getvalue (i,j) {
        return this.m[i-this.imin][j-this.jmin];
    }

}

//
// Represents a grid sampling of some field
//
class GridSample {

    // Initializes for a given 2D range and cell size
    constructor (xmin,xmax,ymin,ymax,cellsize) {
        this.xmin = xmin;
        this.xmax = xmax;
        this.ymin = ymin;
        this.ymax = ymax;
        this.nx = ~~((xmax-xmin)/cellsize)+1;
        this.dx = (xmax-xmin) / this.nx;
        this.ny = ~~((ymax-ymin)/cellsize)+1;
        this.dy = (ymax-ymin) / this.ny;
        this.s = [];
        for (var i = 0; i < this.ny; i++) {
            var row = [];
            for (var j = 0; j < this.nx; j++) {
                row[j] = 0;
            }
            this.s[i] = row;
        }
    }

    // Samples a field at the given 2D range and adds it to the grid
    // cells multiplied by the given scale factor. Returns a SampleCache
    // object that can then be reused with the addCache method
    addField (field, scale, xmin, xmax, ymin, ymax) {
        var imin = Math.max (~~((ymin - this.ymin) / this.dy), 0);
        var imax = Math.min (~~((ymax - this.ymin) / this.dy)+1, this.ny);
        var jmin = Math.max (~~((xmin - this.xmin) / this.dx), 0);
        var jmax = Math.min (~~((xmax - this.xmin) / this.dx)+1, this.nx);
        var cache = new SampleCache(imin,imax,jmin,jmax);
        for (var i = imin; i < imax; i++) {
            var y = this.ymin + i * this.dy;
            for (var j = jmin; j < jmax; j++) {
                var x = this.xmin + j * this.dx;
                var v = field (x,y);
                cache.setvalue (i,j,v)
                this.s[i][j] += scale * v;
            }
        }
        return cache;
    }

    // Adds the values in the given cache to the sample grid multiplied by scale
    addCache (cache, scale) {
        for (var i = cache.imin; i < cache.imax; i++) {
            for (var j = cache.jmin; j < cache.jmax; j++) {
                this.s[i][j] += scale * cache.getvalue(i,j);
            }
        }
    }

    // Returns an array of curves representing the contours for the given level
    polygonize (level)   {
        var curves = marching_squares (this.s, level);
        for (let c of curves) {
            for (let p of c.pts) {
                p.x = p.x * this.dx + this.xmin;
                p.y = p.y * this.dy + this.ymin;
            }
        }
        return curves;
    }
}


//
// Reclusters an array of clusters based on distance according to the
// algorithm in the bubble cluster paper. clusters is the original
// clustering and mindist and maxdist correspond to the "small value" and
// "large value" in the paper. If exclusion is provided, it should be a function
// of the form exclusion(a,b) that returns true if element pair a,b is not
// to be merged. Returns the new reclustered array
//
function recluster (clusters, mindist, maxdist, exclusion) {
    exclusion = exclusion || function (a,b) { return false };
    var objects = [];
    var oldgroup = [], newgroup = [];
    var oldsets = [];
    var i = 0, j = 0;
    for (let c of clusters) {
        for (let e of c) {
            objects [j] = e;
            oldgroup [j] = i;
            newgroup [j] = j;
            j++;
        }
        oldsets [i] = new Set(c); 
        i++;
    }
    for (i = 0; i < objects.length; i++) {
        for (j = i+1; j < objects.length; j++) {
            var threshold = oldgroup[i]==oldgroup[j] ? maxdist : mindist;
            if (newgroup[i] != newgroup[j] && objects[i].distance(objects[j]) <= threshold && 
                !exclusion (objects[i], objects[j])) {
                // Merge class i with class j
                src = newgroup[j];
                dst = newgroup[i];
                for (var k = 0; k < objects.length; k++) {
                    if (newgroup[k] == src) newgroup [k] = dst;
                }
            }
        }
    }
    var s = new Set();
    var newclusters = [];
    var total = 0;
    for (i = 0; i < newgroup.length; i++) {
        var g = newgroup[i];
        if (! s.has(g)) {
            s.add(g);
            var c = new Cluster();
            var oldset = oldsets [oldgroup[i]];
            var samegroup = true;
            for (j = i; j < objects.length; j++) {
                if (newgroup[j] == g) {
                    c.push (objects[j]);
                }
                if (!oldset.has(objects[j])) samegroup = false;
            }
            newclusters.push (c);
            var oldc = clusters[oldgroup[i]];
            if (samegroup && oldc.length == c.length && oldc.dirty == false) {
                c.dirty = false;
                c.cache = oldc.cache;
                total += 1;
            }
        }
    }
    return newclusters;
}


var clusters; // Collection of Clusters
var level = 0; // Current clusterization level
var maxlevel = 5; // Maximum number of clusterization levels
var levelConnectors = [[],[],[],[],[]]; // Collections of connectors per level
var exclusion = null; // A function to exclude the clustering of some element pairs
var sel = null; // Selected (dragging) cluster / element if any
var grid = null;  // The current sampling of the scalar field

// Geometric constants related to the bubble cluster algorithm
var dilation_base = 10;
var dilation_increment = 10;
var dilation_radius = dilation_base;
var grid_spacing = 8.0;
var level_offset = 0.2;


// 
// Creates a higher level aggregation from an array of clusters, i.e.,
// creates an array of clusters containing one cluster each
//
function upLevel (clusters) {
    var newclusters = [];
    for (let c of clusters) {
        var newc = new Cluster();
        newc.push (c);
        newclusters.push (newc);
    }
    return newclusters;
}

// 
// Creates a lower level aggregation from an array of clusters by
// removing the contents of clusters and putting them in the result array
//
function downLevel (clusters) {
    var newclusters = [];
    for (let c of clusters) {
        for (let e of c) {
            if (e instanceof Cluster) {
                newclusters.push (e)
            }
            else {
                var newc = new Cluster();
                newc.push (e);
                newclusters.push (newc);
            }
        }
    }
    return newclusters;
}



// Interaction modes
var panMode = 0, dragMode = 1, drawMode = 2, mode = dragMode;

var inputLine = null; // A line segment to be drawn in drawMode

function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
}

function mousePressed() {
    sel = null;
    dragStart = makePoint (mouseX,mouseY);
    if (mode == dragMode) {
        for (let c of clusters) {
            var d = c.distancePoint (dragStart);
            if (d <= dilation_radius) {
                for (let e of c) {
                    if (e.contains (dragStart) && ! (e instanceof ClusterConnector)) {
                        sel = e; // An element was picked
                        break;
                    }
                }
                if (sel == null) sel = c; // The cluster was picked
            }
        }
        if (sel == null && level == 0) {
            var tmp = new Cluster();
            tmp.push (new ClusterElement(dragStart, 10));
            clusters.push (tmp);
        }
        clusters = recluster(clusters, dilation_radius, dilation_radius*2, exclusion);
    }
    else if (mode == drawMode) {
        inputLine = [dragStart, makePoint (mouseX, mouseY)];
    }
}

function mouseDragged() {
    var p = makePoint (mouseX,mouseY);
    if (mode == dragMode) {
        if (sel) {
            sel.translate (subVectors(p,dragStart));
            dragStart = p;
        }
        else if (level == 0 && distPoints (p, dragStart) >= 10) {
            var tmp = new Cluster();
            tmp.push (new ClusterElement(p, 10));
            clusters.push (tmp);
            dragStart = p;
        } 
        clusters = recluster(clusters, dilation_radius, dilation_radius*2, exclusion);
    }
    else if (mode == drawMode && inputLine) {
        inputLine [1] = p;
    }
}

function mouseReleased() { 
    sel = null;
    exclusion = null;
    if (inputLine) {
        if (mode == drawMode) {
            // Classify the stroke
            var first = null, last = null;
            for (let c of clusters) {
                for (let o of c.outline) {
                    if (o.insidePoint (inputLine[0])) {
                        first = c.closestElement(inputLine[0]);
                    }
                    if (o.insidePoint (inputLine[1])) {
                        last = c.closestElement(inputLine[1]);
                    }
                }
            }
            if (first != null && last != null && first != last) {
                // Stroke linking two distinct clusters
                var tmp = new Cluster();
                tmp.push (new ClusterConnector(first, last, 1));
                clusters.push (tmp);
                clusters = recluster(clusters, dilation_radius, dilation_radius*2, exclusion);
            }
            else {
                // Test whether stroke cuts a link and remove it
                var changed = false;
                for (let c of clusters) {
                    for (let e of c.connectors()) {
                        if (e.crosses (inputLine[0], inputLine[1])) {
                            c.remove (e);
                            changed = true;
                            break;
                        }
                    }
                }
                if (changed) {
                    clusters = recluster(clusters, dilation_radius, dilation_radius*2, exclusion);
                } else {
                    // Test for an exclusion stroke
                    for (let c of clusters) {
                        var ex = new ClusterExclusion (c, inputLine[0], inputLine[1], dilation_radius*4);
                        if (ex.count() > 0) {
                            console.log (ex.count())
                            exclusion = ex.exclusion();
                            clusters = recluster(clusters, dilation_radius, dilation_radius*2, exclusion);
                            break;
                        }
                    }
                }
            }
        }
        inputLine = null;
    }
}

function keyPressed() {
    if (keyCode == SHIFT) {
        mode = drawMode;
        cursor (CROSS);
    }
    if (key == "U" || key == "u") {
        if (level+1 < maxlevel) {
            levelConnectors[level] = [];
            // for (let c of clusters) {
            //     for (let con of c.connectors()) {
            //         levelConnectors [level].push (con);
            //         c.remove (con);
            //     }
            // }
            clusters = upLevel (clusters);
            level += 1;
            for (let con of levelConnectors[level]) {
                var c = new Cluster();
                c.push (con);
                clusters.push(c);
            }
            dilation_radius = dilation_base + level * dilation_increment;
            clusters = recluster(clusters, dilation_radius*1.5, dilation_radius*1.5, exclusion);
        }
    }
    else if (key == "D" || key == "d") {
        if (level > 0) {
            dilation_radius = 0.5 * dilation_radius;
            levelConnectors[level] = [];
            for (let c of clusters) {
                for (let con of c.connectors()) {
                    levelConnectors [level].push (con);
                    c.remove (con);
                }
            }
            clusters = downLevel (clusters);
            level -= 1;
            for (let con of levelConnectors[level]) {
                var c = new Cluster();
                c.push (con);
                clusters.push(c);
            }
            dilation_radius = dilation_base + level * dilation_increment;
            clusters = recluster(clusters, dilation_radius*1.5, dilation_radius*1.5, exclusion);
        }
    }
}

function keyReleased() {
    if (mode == drawMode) {
        cursor (ARROW);
        mode = dragMode;
    }
}


//
// Creates drawing, a set of polygons traced by applying marching squares
// on a potential field created from clusters.
//
function polygonize () {

    // First test whether we need to polygonize at all
    var needed = false;
    var neededBox = null;
    for (let cluster of clusters) {
        if (cluster.dirty || cluster.outline.length == 0) {
            if (!needed) {
                neededBox = cluster.bbox();
            }
            else {
                neededBox = neededBox.union (cluster.bbox());
            }
            needed = true;
        }
    }
    if (!needed) return;

    // Build another sampling of the scalar field
    grid = new GridSample(0,width,0,height,grid_spacing);

    for (let cluster of clusters) {
        cluster.set_field (dilation_radius*1.5);
        var box = cluster.bbox();
        if (cluster.dirty) {
            var cache = grid.addField (cluster.field, -1, box.x, box.x+box.width, box.y, box.y+box.height);
            cluster.cache = cache;
        }
        else {
            grid.addCache (cluster.cache,-1);
        }
        
    }
    for (let cluster of clusters) {
        var box = cluster.bbox();
        if (cluster.dirty || box.intersection (neededBox)) { 
            grid.addCache(cluster.cache,2);
            cluster.outline = grid.polygonize (level_offset);
            grid.addCache(cluster.cache,-2);
            cluster.dirty = false;
        }
    }
}

function setup() {
    makeVector = createVector; // Use p5's vector
    createCanvas (windowWidth, windowHeight);

    clusters = [];

    clusters = recluster(clusters, dilation_radius, dilation_radius*2);
}

function draw() {
    background(255);

    // sel might have moved to another cluster
    if (sel && sel instanceof Cluster) {
        for (let c of clusters) {
            if (c.common(sel).size > 0) {
                sel = c;
                break
            }
        }
    }

    polygonize();

    // Draw the elements
    fill (0);
    noStroke();
    clusters.forEach (function (e) {
        e.draw();
    });

    // If the elements are themselves clusters, draw their outlines
    noFill();
    stroke (0,0,255);
    for (let c of clusters) {
        for (let e of c) {
            if (e['outline'] != undefined) {
                for (let contour of e['outline']) {
                    contour.draw();
                }
            }
        }
    }

    // Draw the cluster outlines
    stroke (200,0,0);
    for (let c of clusters) {
        for (let contour of c['outline']) {
            contour.draw();
        }
    }

    // Draw the line input if any
    if (inputLine != null) {
        stroke (0);
        line (inputLine[0].x,inputLine[0].y,inputLine[1].x,inputLine[1].y);
    }

}