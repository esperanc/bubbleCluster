
// Returns a radial kernel function for r0 and r1 as described
// in the bubble cluster paper...
//
function radial_kernel (r0,r1) {
    var a = r1-r0;
    var f = 1.0 / (a*a);
    var b = r0;
    return function (d) {
        var r = d-a-b;
        if (r > 0) return 0.0;
        return f * r * r;
    }
}

// 
// Returns a radial function as described in the bubble cluster
// paper...
//
function radial (x0,y0,r0,r1) {
    var k = radial_kernel (r0, r1);
    return function (x,y) {
        x -= x0;
        y -= y0; 
        return k (Math.sqrt(x*x+y*y));
    }
}

// 
// Returns a distance function to a fixed point
//
function distance_to_point (center, x, y) {
    var dx = x-center.x, dy = y-center.y;
    return Math.sqrt(dx*dx+dy*dy);
}

//
// Encapsulates an object that can be manipulated
//
class ClusterElement {

    // By default, a circle object
    constructor (center, radius, dilation) {
        this.center = center;
        this.radius = radius;
        this.set_field (dilation);
    }

    // Alter the field generated by this element by choosing another dilation
    set_field (dilation) {
        this.dilation = dilation || 20;
        this.field = radial (this.center.x, this.center.y, this.radius, this.radius+this.dilation);
    }

    // Draw the object
    draw() {
        ellipse (this.center.x, this.center.y, this.radius*2, this.radius*2);
    }
}

// 
// Generates a potential field for a set of ClusterElements
// that is a sum of radial fields of all elements
//
function potential_field (set, dilation) {
    for (let e of set) {
        e.set_field (dilation);
    }
    return function (x,y) {
        var s = 0;
        for (let e of set) {
            s += e.field(x,y);
        }
        return s;
    }
}

// 
// Generates a distance field for a set of ClusterElements
// using the minimum of distance functions for each ClusterElement
//
function distance_field (set) {
    return function (x,y) {
        var s = 1e10;
        for (let t of set) {
            s = Math.min(Math.max (distance_to_point (t.center, x, y) - t.radius, 0), s);
        }
        return s;
    }
}

//
// Samples a field with nx*ny points for  x0 <= x < x0+dx*nx and  
// y0 <= y < y0+dy*ny and returns a matrix with the sampled values
//
function sample_field (field, x0,dx,nx,y0,dy,ny) {
    var result = []
    for (var i = 0; i < ny; i++) {
        var row = [];
        var y = y0 + i*dy;
        for (var j = 0; j < nx; j++) {
            var x = x0 + j*dx;
            row [j] = field(x,y);
        }
        result[i] = row;
    }
    return result;
}


var elements; // Collection of ClusterElement objects
var groups; // Collection of collection of ClusterElement objects
var sel; // Selected (dragging) object if any

function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
}

function mousePressed() {
    sel = null;
    dragStart = makePoint (mouseX,mouseY);
    for (let e of elements) {
        if (dist (e.center.x, e.center.y, mouseX, mouseY) <= e.radius) {
            sel = e;
        }
    }
}

function mouseDragged() {
    if (sel) {
        var p = makePoint (mouseX,mouseY);
        sel.center = addVectors(sel.center, subVectors(p,dragStart));
        dragStart = p;
    }
}

function mouseReleased() { 
    sel = null;
}

function keyPressed() {

}

var drawing;
var dilation_radius = 40;
var grid_spacing = 5.0;
var level_offset = 0.1;


//
// Creates drawing, a set of polygons traced by applying marching squares
// on a potential field created from elements.
//
function polygonize () {

    var field;
    if (sel) {
        // An element is selected: contribution of the selected 
        // element should have opposite sign from that of the
        // other elsments
        var tmp1 = [];
        for (let e of elements) {
            if (e != sel) tmp1.push(e);
        }
        var tmp2 = [sel];
        var f1 = potential_field (tmp1, dilation_radius); 
        var f2 = potential_field (tmp2, dilation_radius); 
        field = function (x,y) {
            return f1(x,y) - f2(x,y);
        }
    }
    else {
        // All elements with the same sign
        field = potential_field (elements, dilation_radius); 
    }

    var nx = ~~(width/grid_spacing);
    var ny = ~~(height/grid_spacing);
    var s = sample_field(field, 0, grid_spacing,  nx, 0, grid_spacing, ny);
    drawing = marching_squares (s, level_offset);

    // If object is selected, invert the field so we can trace
    // the contour of the selected object
    if (sel) {
        for (let row of s) {
            for (var i = 0; i < row.length; i++) {
                row[i] = -row[i];
            }
        }
        drawing = drawing.concat (marching_squares (s, level_offset));
    }

    // Scale the polygons to the actual size of the screen
    var scale = makeVector(grid_spacing,grid_spacing);
    for (let c of drawing) {
        c.scale(scale);
    }

}

function setup() {
    makeVector = createVector; // Use p5's vector
    createCanvas (windowWidth, windowHeight);

    elements = new Set([new ClusterElement(createVector(200,200), 60),
                        new ClusterElement(createVector(400,200), 80),
                        new ClusterElement(createVector(300,400), 40)]);

}

function draw() {
    background(0);

    polygonize();

    fill (255);
    noStroke();
    elements.forEach (function (e) {
        e.draw();
    });

    noFill();
    stroke (255,255,0)
    drawing.forEach (function (c) {
        c.draw();
    });
}